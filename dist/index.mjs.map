{"version":3,"sources":["../src/types.ts","../src/api.ts","../src/constants.ts","../src/websocket.ts","../src/sailfish.ts"],"sourcesContent":["export type SailfishCallbacks = {\n  onMessage: (message: SailfishMessage) => void;\n  onTokenInit: (message: TokenInit) => void;\n  onTokenMint: (message: TokenMint) => void;\n  onTokenGraduate: (message: PoolInit) => void;\n  onPoolInit: (poolInit: PoolInit) => void;\n  onTradeRaw: (tradeRaw: TradeRaw) => void;\n  onTrade: (trade: Trade) => void;\n}\n\nexport enum SailfishEventType {\n  Event = \"event\",\n  Signal = \"signal\",\n}\n\nexport enum SailfishEventResource {\n  TokenInits = \"token-inits\",\n  TokenMints = \"token-mints\",\n  TokenGraduates = \"token-graduates\",\n  PoolInits = \"pool-inits\",\n  PoolGraduates = \"pool-graduates\",\n  TradesRaw = \"trades-raw\",\n}\n\nexport enum PoolType {\n  RaydiumAmm = \"RaydiumAmm\",\n  RaydiumCpmm = \"RaydiumCpmm\",\n  RaydiumClmm = \"RaydiumClmm\",\n  RaydiumLaunchpad = \"RaydiumLaunchpad\",\n  PumpSwapAmm = \"PumpSwapAmm\",\n  PumpFunAmm = \"PumpFunAmm\",\n  MeteoraDyn = \"MeteoraDyn\",\n  MeteoraDynV2 = \"MeteoraDynV2\",\n}\n\nexport type SailfishMessage = {\n  type: SailfishEventType,\n  resource: SailfishEventResource,\n  data: any,\n}\n\nexport interface Filter {\n  token_addresses: string[];\n  pool_addresses: string[];\n  dex_types: string[];\n}\n\nexport type TokenInfo = {\n  address: string,\n  name: string,\n  symbol: string,\n  decimals: number,\n  total_supply: string,\n}\n\nexport type PoolInfo = {\n  pool_type: PoolType,\n  address: string,\n  quote_token: TokenInfo,\n  base_token: TokenInfo,\n  buy_path: string[],\n  sell_path: string[],\n  token_0: string,\n  token_1: string,\n}\n\nexport type TradeIndex = {\n  tick: number, // @dev - This is usually the block/slot number of the trade.\n  index_a: number, // @dev - This is usually the index of the trade in within the tick. Think of it as the tx index.\n  index_b: number, // @dev - This is usually the index of the trade within the tx. Remember one tx can have multiple trades.\n  tx_hash: string, // @dev - This is the hash of the transaction that the trade occurred in.\n}\n\nexport type Trade = {\n  index: TradeIndex,\n\n  pool_address: string, // @dev - This is the address of the pool that the trade occurred in.\n  quote_token_address: string, // @dev - This is the address of the quote token.\n  base_token_address: string, // @dev - This is the address of the base token.\n\n  quote_amount: string, // @dev - This is the signed amount of the quote token change. Quote token is usually WSOL/SOL/ETH/WETH. Could also be USDC/USDT/etc.\n  base_amount: string, // @dev - This is the signed amount of the base token change. Base token is usually the token being traded.\n\n  price: string, // @dev - This is the price of the trade base_token/quote_token.\n  fee: string, // @dev - This is the fee usually in ETH/SOL that was paid for the trade.\n  bribe: string, // @dev - This is the bribe usually in ETH/SOL that was paid for the trade.\n\n  from_wallet: string, // @dev - This is the wallet address of the trader that made the trade.\n  to_wallet: string, // @dev - This is the wallet address of the trader that received the trade.\n\n  from_wallet_account: string | null, // @dev - This is the wallet account of the trader that made the trade, applies only to Solana.\n  to_wallet_account: string | null, // @dev - This is the wallet account of the trader that received the trade, applies only to Solana.\n}\n\nexport type TradeRaw = {\n  index: TradeIndex,\n\n  pool_type: string,\n  pool_address: string,\n\n  token_address_in: string,\n  token_amount_in: string,\n\n  token_address_out: string,\n  token_amount_out: string,\n\n  price: string,\n  fee: string,\n  bribe: string,\n\n  to_wallet: string,\n  from_wallet: string,\n\n  from_account: string,\n  to_account: string,\n}\n\nexport type SolTxData = {\n  slot: number,\n  version: string,\n  first_signer: string,\n  first_signature: string,\n  all_signers: string[],\n  all_signatures: string[],\n  fee: number,\n  bribe: number,\n  priority_fee: number | null,\n  index_in_slot: number | null,\n}\n\nexport type InstructionPosition = {\n  parent_index: number,\n  child_index: number | null,\n}\n\nexport type PoolInit = {\n  tx: SolTxData,\n  pool_type: PoolType,\n  pool_address: string,\n  token_0_mint: string,\n  token_1_mint: string,\n}\n\nexport type TokenInit = {\n  tx: SolTxData,\n  instruction_position: InstructionPosition,\n  program_id: string,\n  decimals: number,\n  mint: string,\n  mint_authority: string | null,\n}\n\nexport type TokenMint = {\n  tx: SolTxData,\n  instruction_position: InstructionPosition,\n  program_id: string,\n  account: string,\n  amount: string,\n  mint: string,\n  mint_authority: string | null,\n}\n\nexport type TradesQuery = {\n  lower_tick: number,\n  upper_tick: number,\n  pool_types: PoolType[],\n  pool_addresses: string[],\n  token_addresses: string[],\n  to_wallets: string[],\n  from_wallets: string[],\n}\n\nexport type GraduatedPoolsQuery = {\n  lower_tick: number,\n  upper_tick: number,\n  pool_types: PoolType[],\n  pool_addresses: string[],\n  token_addresses: string[],\n  // creator_addresses: string[],\n}\n\nexport type IndexedPumpFunGraduatedPool = {\n  created_at: Date,\n  slot: number,\n  version: string,\n  first_signer: string,\n  first_signature: string,\n  all_signers: string[],\n  all_signatures: string[],\n  fee: number,\n  priority_fee: number,\n  index_in_slot: number,\n  bribe: number,\n\n  global: string,\n  withdraw_authority: string,\n  mint: string,\n  bonding_curve: string,\n  associated_bonding_curve: string,\n  user: string,\n  system_program: string,\n  token_program: string,\n  pump_amm: string,\n  pool: string, // @dev this is the pool address on pumpswap for the new graduated pool.\n  pool_authority: string,\n  pool_authority_mint_account: string,\n  pool_authority_wsol_account: string,\n  amm_global_config: string,\n  wsol_mint: string,\n  lp_mint: string,\n  user_pool_token_account: string,\n  pool_base_token_account: string,\n  pool_quote_token_account: string,\n  token_2022_program: string,\n  associated_token_program: string,\n  pump_amm_event_authority: string,\n  event_authority: string,\n  program: string,\n  coin_creator: string,\n}\n\n\nexport type IndexedRaydiumLaunchpadMigrateToAmm = {\n  created_at: Date,\n  slot: number,\n  version: string,\n  first_signer: string,\n  first_signature: string,\n  all_signers: string[],\n  all_signatures: string[],\n  fee: number,\n  priority_fee: number,\n  index_in_slot: number,\n  bribe: number,\n\n  // Accounts\n  payer: string,\n  base_mint: string,\n  quote_mint: string,\n  openbook_program: string,\n  market: string,\n  request_queue: string,\n  event_queue: string,\n  bids: string,\n  asks: string,\n  market_vault_signer: string,\n  market_base_vault: string,\n  market_quote_vault: string,\n  amm_program: string,\n  amm_pool: string,\n  amm_authority: string,\n  amm_open_orders: string,\n  amm_lp_mint: string,\n  amm_base_vault: string,\n  amm_quote_vault: string,\n  amm_target_orders: string,\n  amm_config: string,\n  amm_create_fee_destination: string,\n  authority: string,\n  pool_state: string,\n  global_config: string,\n  base_vault: string,\n  quote_vault: string,\n  pool_lp_token: string,\n  spl_token_program: string,\n  associated_token_program: string,\n  system_program: string,\n  rent_program: string,\n\n  // Data\n  base_lot_size: number,\n  quote_lot_size: number,\n  market_vault_signer_nonce: number,\n}\n\n\nexport type IndexedRaydiumLaunchpadMigrateToCpswap = {\n  created_at: Date,\n  slot: number,\n  version: string,\n  first_signer: string,\n  first_signature: string,\n  all_signers: string[],\n  all_signatures: string[],\n  fee: number,\n  priority_fee: number,\n  index_in_slot: number,\n  bribe: number,\n\n  // Accounts\n  payer: string,\n  base_mint: string,\n  quote_mint: string,\n  platform_config: string,\n  cpswap_program: string,\n  cpswap_pool: string,\n  cpswap_authority: string,\n  cpswap_lp_mint: string,\n  cpswap_base_vault: string,\n  cpswap_quote_vault: string,\n  cpswap_config: string,\n  cpswap_create_pool_fee: string,\n  cpswap_observation: string,\n  lock_program: string,\n  lock_authority: string,\n  lock_lp_vault: string,\n  authority: string,\n  pool_state: string,\n  global_config: string,\n  base_vault: string,\n  quote_vault: string,\n  pool_lp_token: string,\n  base_token_program: string,\n  quote_token_program: string,\n  associated_token_program: string,\n  system_program: string,\n  rent_program: string,\n  metadata_program: string,\n}\n\nexport type RawGraduations = {\n  pumpswap_graduations: IndexedPumpFunGraduatedPool[],\n  raydium_amm_graduations: IndexedRaydiumLaunchpadMigrateToAmm[],\n  raydium_cpmm_graduations: IndexedRaydiumLaunchpadMigrateToCpswap[],\n}","import axios from \"axios\";\nimport type { PoolInfo, TokenInfo, TradesQuery, Trade, GraduatedPoolsQuery, RawGraduations } from \"./types\";\nimport { PRODUCTION_API_URL } from \"./constants\";\n\nconst AXIOS_CONFIG = { headers: { \"Content-Type\": \"application/json\" }, timeout: 10 * 60 * 1000 };\nexport class SailfishApi {\n  private baseUrl: string;\n  constructor(\n    baseUrl: string = PRODUCTION_API_URL,\n  ) {\n    this.baseUrl = baseUrl;\n  }\n\n  public async fetchLatestBlock(): Promise<number | Error> {\n    const url = `${this.baseUrl}/tick`;\n    const response = await axios.get<number>(url, AXIOS_CONFIG);\n    if (response.status !== 200) {\n      return new Error(`Failed to fetch latest block: ${response.statusText}`);\n    }\n    return response.data;\n  }\n\n  public async fetchPoolInfo(address: string): Promise<PoolInfo | Error> {\n    const url = `${this.baseUrl}/sailfish/pools/query`;\n    const response = await axios.post<PoolInfo>(url, address, AXIOS_CONFIG);\n    if (response.status !== 200) {\n      return new Error(`Failed to fetch pool info: ${response.statusText}`);\n    }\n    return response.data;\n  }\n\n  public async fetchTokenInfo(address: string): Promise<TokenInfo | Error> {\n    const url = `${this.baseUrl}/sailfish/tokens/query`;\n    const response = await axios.post<TokenInfo>(url, address, AXIOS_CONFIG);\n    if (response.status !== 200) {\n      return new Error(`Failed to fetch token info: ${response.statusText}`);\n    }\n    return response.data;\n  }\n\n  public async fetchTrades(query: TradesQuery): Promise<Record<string, Trade[]> | Error> {\n    const url = `${this.baseUrl}/sailfish/trades/query`;\n    try {\n      const response = await axios.post<Record<string, Trade[]>>(url, query, AXIOS_CONFIG);\n      if (response.status !== 200) {\n        return new Error(`Failed to fetch trades: ${response.statusText}`);\n      }\n      return response.data as Record<string, Trade[]>;\n    } catch (error) {\n      if (error instanceof Error) {\n        return error;\n      }\n      return new Error(`Unexpected error: ${error}`);\n    }\n  }\n\n  public async fetchRawGraduations(query: GraduatedPoolsQuery): Promise<RawGraduations | Error> {\n    const url = `${this.baseUrl}/sailfish/graduated_pools_raw/query`;\n    try {\n      const response = await axios.post<RawGraduations>(url, query, AXIOS_CONFIG);\n      if (response.status !== 200) {\n        return new Error(`Failed to fetch raw graduations: ${response.statusText}`);\n      }\n      return response.data as RawGraduations;\n    } catch (error) {\n      return new Error(`Failed to fetch graduated pools: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n}","export const PRODUCTION_API_URL = \"https://sailfish.0xfire.com\";\nexport const PRODUCTION_WS_URL = \"wss://sailfish.0xfire.com/stream/public/ws\";","import type { Filter, SailfishMessage } from \"./types\";\nimport WebSocket from \"isomorphic-ws\";\n\nexport class SailfishWebsocket {\n  private socket: WebSocket | null = null;\n  private reconnectAttempts: number = 0;\n  private reconnecting: boolean = false;\n  private readonly maxReconnects = 50;\n  private readonly reconnectDelay = 1000;\n\n  public readonly botName: string;\n  public readonly ws_url: string;\n  public enabled: boolean = true;\n  public connecting: boolean = false;\n  public connected: boolean = false;\n\n  private callback: (message: SailfishMessage) => void;\n\n  private filter: Filter;\n\n  constructor(\n    ws_url: string,\n    botName: string,\n    filter: Filter,\n    callback: (message: SailfishMessage) => void,\n  ) {\n    this.botName = botName;\n    this.ws_url = ws_url;\n    this.filter = filter;\n    this.callback = callback;\n    this._start();\n  }\n\n  public updateFilter(newFilter: Filter) {\n    this.filter = newFilter;\n    this.send({ type: \"updateFilter\", filter: newFilter });\n  }\n\n  private _start() {\n    if (!this.enabled || this.reconnecting) return;\n\n    if (this.reconnectAttempts >= this.maxReconnects) {\n      console.warn(`Max reconnect attempts reached for ${this.botName}`);\n      return;\n    }\n\n    this.reconnectAttempts++;\n    this.connecting = true;\n    console.log(`Connecting to ${this.ws_url} for ${this.botName}, attempt ${this.reconnectAttempts}`);\n\n    this.socket = new WebSocket(this.ws_url);\n    this.socket.addEventListener(\"open\", this.onOpen.bind(this));\n    this.socket.addEventListener(\"message\", this.onMessage.bind(this));\n    this.socket.addEventListener(\"close\", this.onClose.bind(this));\n    this.socket.addEventListener(\"error\", this.onError.bind(this));\n  }\n\n  private onOpen() {\n    console.log(`Connected to ${this.ws_url} for ${this.botName}`);\n    this.connected = true;\n    this.connecting = false;\n    this.reconnecting = false;\n    this.reconnectAttempts = 0;\n    this.socket?.send(\"Hello Server!\");\n    this.updateFilter(this.filter); // bootstrap filter\n  }\n\n  private onMessage(event: MessageEvent) {\n    try {\n      const data = JSON.parse(event.data);\n      this.callback(data);\n    } catch (err) {\n      console.error(`Failed to parse message for ${this.botName}`, err);\n    }\n  }\n\n  private onClose(event: CloseEvent) {\n    console.warn(`Socket closed for ${this.botName}`, event);\n    this.connected = false;\n    this.connecting = false;\n    this.scheduleReconnect();\n  }\n\n  private onError(event: Event) {\n    console.error(`WebSocket error for ${this.botName}`, event);\n    this.socket?.close(); // Trigger reconnect\n  }\n\n  private scheduleReconnect() {\n    if (!this.enabled || this.reconnecting) return;\n\n    this.reconnecting = true;\n    setTimeout(() => {\n      this.reconnecting = false;\n      this._start();\n    }, this.reconnectDelay);\n  }\n\n  public stop() {\n    this.enabled = false;\n    this.connected = false;\n    this.connecting = false;\n    this.socket?.close();\n    this.socket = null;\n  }\n\n  public send(data: string | object) {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      console.warn(`Cannot send message; socket not open for ${this.botName}`);\n      return;\n    }\n\n    const payload = typeof data === \"string\" ? data : JSON.stringify(data);\n    this.socket.send(payload);\n  }\n}\n","import {\n  type TokenInfo,\n  type PoolInfo,\n  type Filter,\n  type SailfishMessage,\n  type TradeRaw,\n  type SailfishCallbacks,\n  SailfishEventResource,\n  type Trade,\n  type PoolInit,\n  PoolType,\n  type TokenMint,\n  type TokenInit,\n} from \"./types\";\n\nimport { SailfishApi } from \"./api\";\nimport { SailfishWebsocket } from \"./websocket\";\nimport { PRODUCTION_WS_URL, PRODUCTION_API_URL } from \"./constants\";\n\nexport const DEFAULT_QUOTE_TOKEN_ADDRESSES: string[] = [\n  \"11111111111111111111111111111111\", // SOL\n  \"So11111111111111111111111111111111111111112\", // WSOL\n  \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\", // USDC\n  \"USD1ttGY1N17NEEHLmELoaybftRBUSErhqYiQzvEmuB\", // USD1\n];\n\nexport const BONDING_CURVE_POOL_TYPES: PoolType[] = [\n  PoolType.PumpFunAmm,\n  PoolType.RaydiumLaunchpad,\n];\n\nexport function amountToFloatString(amount: string | number, decimals: number): string {\n  if (amount === null || amount === undefined) {\n    console.error(\"amountToFloatString received undefined/null amount\");\n    return \"0\";\n  }\n\n  const amountStr = String(amount);\n\n  const padded = amountStr.padStart(decimals + 1, \"0\");\n  const integerPart = padded.slice(0, padded.length - decimals) || \"0\";\n  const fractionalPart = padded.slice(padded.length - decimals);\n\n  return `${integerPart}.${fractionalPart}`;\n}\n\nexport function getTradeData(poolInfo: PoolInfo, tradeRaw: TradeRaw): any {\n  let quoteAmount = \"0\";\n  let baseAmount = \"0\";\n  let price = \"0\";\n\n  if (poolInfo.quote_token.address.toLowerCase() === tradeRaw.token_address_in.toLowerCase()) {\n    // This is a buy trade.\n    quoteAmount = `-${amountToFloatString(tradeRaw.token_amount_in, poolInfo.quote_token.decimals)}`;\n    baseAmount = amountToFloatString(tradeRaw.token_amount_out, poolInfo.base_token.decimals);\n  } else {\n    // This is a sell trade.\n    quoteAmount = amountToFloatString(tradeRaw.token_amount_out, poolInfo.quote_token.decimals);\n    baseAmount = `-${amountToFloatString(tradeRaw.token_amount_in, poolInfo.base_token.decimals)}`;\n  }\n\n  price = (Math.abs(parseFloat(quoteAmount)) / Math.abs(parseFloat(baseAmount))).toString();\n\n  return {\n    quote_amount: quoteAmount,\n    base_amount: baseAmount,\n    price: price,\n  }\n}\n\nexport function getQuoteAndBaseTokenInfos(token0Info: TokenInfo, token1Info: TokenInfo, supportedQuoteTokens: string[] = DEFAULT_QUOTE_TOKEN_ADDRESSES): { quoteTokenInfo: TokenInfo, baseTokenInfo: TokenInfo } {\n  if (supportedQuoteTokens.includes(token0Info.address)) {\n    return { quoteTokenInfo: token0Info, baseTokenInfo: token1Info };\n  }\n  if (supportedQuoteTokens.includes(token1Info.address)) {\n    return { quoteTokenInfo: token1Info, baseTokenInfo: token0Info };\n  }\n  throw new Error(`No supported quote token found for ${token0Info.address} and ${token1Info.address}`);\n}\n\nexport class Sailfish {\n  private filter: Filter;\n  private wsUrl: string;\n  private ws: SailfishWebsocket | null = null;\n  private api: SailfishApi;\n  private poolInfos: Record<string, PoolInfo>;\n  private tokenInfos: Record<string, TokenInfo>;\n  private callbacks: SailfishCallbacks;\n\n  constructor(\n    callbacks: SailfishCallbacks,\n    filter: Filter,\n    apiUrl: string = PRODUCTION_API_URL,\n    wsUrl: string = PRODUCTION_WS_URL,\n  ) {\n    this.api = new SailfishApi(apiUrl);\n    this.callbacks = callbacks;\n    this.filter = filter;\n    this.wsUrl = wsUrl;\n    this.poolInfos = {};\n    this.tokenInfos = {};\n  }\n\n  public isRunning(): boolean {\n    return this.ws !== null && this.ws.connected;\n  }\n\n  public swim() {\n    if (this.ws !== null) {\n      return;\n    }\n\n    this.ws = new SailfishWebsocket(\n      this.wsUrl,\n      \"sailfish-ws\",\n      this.filter,\n      (message: SailfishMessage) => { this.onMessage(message) },\n    );\n  }\n\n\n  public rest() {\n    if (this.ws === null) {\n      return;\n    }\n\n    this.ws.stop();\n    this.ws = null;\n  }\n\n  public onMessage(message: SailfishMessage) {\n    switch (message.resource) {\n      case SailfishEventResource.TokenInits:\n        for (const tokenInit of message.data as TokenInit[]) {\n          this.callbacks.onTokenInit(tokenInit);\n        }\n        break;\n      case SailfishEventResource.TokenMints:\n        for (const tokenMint of message.data as TokenMint[]) {\n          this.callbacks.onTokenMint(tokenMint);\n        }\n        break;\n      case SailfishEventResource.TokenGraduates:\n        for (const poolInit of message.data as PoolInit[]) {\n          this.callbacks.onTokenGraduate(poolInit);\n        }\n        break;\n      case SailfishEventResource.PoolInits:\n        for (const poolInit of message.data as PoolInit[]) {\n          this.callbacks.onPoolInit(poolInit);\n        }\n        break;\n      case SailfishEventResource.TradesRaw:\n        const tradesRaw = message.data as TradeRaw[];\n        for (const tradeRaw of tradesRaw) {\n          this.callbacks.onTradeRaw(tradeRaw);\n          const trade = this.convertTradeRawToTrade(tradeRaw);\n          if (trade !== null) {\n            this.callbacks.onTrade(trade);\n          }\n        }\n        break;\n      default:\n        this.callbacks.onMessage(message);\n        break;\n    }\n  }\n\n  public convertTradeRawToTrade(tradeRaw: TradeRaw): Trade | null {\n    const poolInfo = this.getPoolInfo(tradeRaw.pool_address);\n    if (poolInfo === null) {\n      return null;\n    }\n\n    const tradeData = getTradeData(poolInfo, tradeRaw);\n\n    const trade: Trade = {\n      index: tradeRaw.index,\n      pool_address: tradeRaw.pool_address,\n      quote_token_address: poolInfo.quote_token.address,\n      base_token_address: poolInfo.base_token.address,\n      quote_amount: tradeData.quote_amount,\n      base_amount: tradeData.base_amount,\n      price: tradeData.price,\n      fee: tradeRaw.fee,\n      bribe: tradeRaw.bribe,\n      from_wallet: tradeRaw.from_wallet,\n      to_wallet: tradeRaw.to_wallet,\n      from_wallet_account: tradeRaw.from_account,\n      to_wallet_account: tradeRaw.to_account,\n    };\n\n    return trade;\n  }\n\n  public updateFilter(filter: Filter) {\n    this.filter = filter;\n    if (this.ws !== null) {\n      this.ws.updateFilter(filter);\n    }\n  }\n\n  public hasCachedPoolInfo(poolAddress: string): boolean {\n    return this.poolInfos[poolAddress] !== undefined;\n  }\n\n  public hasCachedTokenInfo(tokenAddress: string): boolean {\n    return this.tokenInfos[tokenAddress] !== undefined;\n  }\n\n  public async fetchPoolInfo(poolAddress: string): Promise<PoolInfo | Error> {\n    if (this.hasCachedPoolInfo(poolAddress)) {\n      return this.poolInfos[poolAddress];\n    }\n\n    try {\n      const newPoolInfo = await this.api.fetchPoolInfo(poolAddress);\n      if (newPoolInfo instanceof Error) {\n        return newPoolInfo;\n      }\n      this.poolInfos[poolAddress] = newPoolInfo;\n      return newPoolInfo;\n    } catch (error) {\n      return new Error(`Failed to fetch pool info: ${error}, use buildPoolInfo instead for ${BONDING_CURVE_POOL_TYPES.join(\", \")} pools`);\n    }\n  }\n\n  public async fetchTokenInfo(tokenAddress: string): Promise<TokenInfo | Error> {\n    if (this.hasCachedTokenInfo(tokenAddress)) {\n      return this.tokenInfos[tokenAddress];\n    }\n\n    try {\n      const newTokenInfo = await this.api.fetchTokenInfo(tokenAddress);\n      if (newTokenInfo instanceof Error) {\n        return newTokenInfo;\n      }\n      this.tokenInfos[tokenAddress] = newTokenInfo;\n      return newTokenInfo;\n    } catch (error) {\n      return new Error(`Failed to fetch token info: ${error}`);\n    }\n  }\n\n  public insertPoolInfo(poolInfo: PoolInfo) {\n    this.poolInfos[poolInfo.address] = poolInfo;\n  }\n\n  public async buildPoolInfoFromPoolInit(\n    poolInit: PoolInit,\n    supportedQuoteTokens: string[] = DEFAULT_QUOTE_TOKEN_ADDRESSES,\n  ): Promise<PoolInfo | Error> {\n    if (this.hasCachedPoolInfo(poolInit.pool_address)) {\n      return this.poolInfos[poolInit.pool_address];\n    }\n\n    const token0Info = await this.fetchTokenInfo(poolInit.token_0_mint);\n    const token1Info = await this.fetchTokenInfo(poolInit.token_1_mint);\n    if (token0Info instanceof Error || token1Info instanceof Error) {\n      return new Error(`Failed to build pool info from pool init: ${token0Info} or ${token1Info}`);\n    }\n\n    const { quoteTokenInfo, baseTokenInfo } = getQuoteAndBaseTokenInfos(token0Info, token1Info, supportedQuoteTokens);\n    const poolInfo = await this.buildPoolInfo(poolInit.pool_type, poolInit.pool_address, quoteTokenInfo, baseTokenInfo);\n    if (poolInfo instanceof Error) {\n      return new Error(`Failed to build pool info from pool init: ${poolInfo}`);\n    }\n\n    return poolInfo;\n  }\n\n  public async buildPoolInfo(\n    poolType: PoolType,\n    poolAddress: string,\n    quoteTokenInfo: TokenInfo,\n    baseTokenInfo: TokenInfo,\n  ): Promise<PoolInfo | Error> {\n    const poolInfo: PoolInfo = {\n      pool_type: poolType,\n      address: poolAddress,\n      quote_token: quoteTokenInfo,\n      base_token: baseTokenInfo,\n      buy_path: [\n        quoteTokenInfo.address,\n        baseTokenInfo.address,\n      ],\n      sell_path: [\n        baseTokenInfo.address,\n        quoteTokenInfo.address,\n      ],\n      token_0: quoteTokenInfo.address,\n      token_1: baseTokenInfo.address,\n    };\n\n    return poolInfo;\n  }\n\n  public getPoolInfo(poolAddress: string): PoolInfo | null {\n    return this.poolInfos[poolAddress] ?? null;\n  }\n\n  public getTokenInfo(tokenAddress: string): TokenInfo | null {\n    return this.tokenInfos[tokenAddress] ?? null;\n  }\n\n  public getAllPools(): Record<string, PoolInfo> {\n    return this.poolInfos;\n  }\n\n  public getAllTokens(): Record<string, TokenInfo> {\n    return this.tokenInfos;\n  }\n\n  public getFilter(): Filter {\n    return this.filter;\n  }\n\n}"],"mappings":"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","names":["SailfishEventType","SailfishEventResource","PoolType"]}